## Lab1

## 总结
主要为TaskManager添加了两个接口用来获取当前运行任务的TCB，并参照原task的相关函数进行了封装。

第一次跑测例，一直跑不通，最后发现是rustsbi的问题，换成0.3.1就好了。

## 简答作业
1. 使用rustsbi 0.3.1， 似乎访问到了错误的地址，输出了大量的乱码，部分输出为Rust的错误处理函数。

2. 
2.1 `a0`是在调用TrapHandler之前，`__alltraps`最后保存的Trap上下文的内核栈栈顶指针。
`__restore`在程序开始之前会运行一次，此时内核处于S态，需要通过trap转向U态来运行用户程序。
第二种情况是发生`ecall`时陷入S态，在`TrapHandler`处理完后，转换U态继续执行用户程序。

2.2 `t0 t1 t2`从Trap上下文分别读出对应CSR寄存器的值
`sstatus`保存Trap之前特权级等信息， `sepc`记录 Trap 发生之前执行的最后一条指令的地址， `sscratch`保存上下文的栈指针。
`sstatus`切换会Trap发生之前的特权级，`sepc`设置Trap返回后执行的下一条指令地址，`sscratch`恢复用户栈

3. `x2`是sp寄存器，保存当前栈顶指针，需要在其他值保存完之后再单独处理。
`x4`线程指针(thread pointer)寄存器，用于线程局部存储，在我们的程序运行期间不会改变，无需保存

4. 这条指令实际上是交换了`sp`和`sscratch`的值，之后`sp`指向用户栈，`sscratch`指向内核栈

5. 最后一行`sret`发生状态切换， 采用传统的函数调用方式将会直接绕过硬件的特权级保护检查，需要用特殊的执行环境切换指令。
`sret`是具有内核态到用户态的执行环境切换能力的函数返回指令

6. 和4类似, 之后`sp`指向内核栈，`sscratch`指向用户栈，

7. 在用户库实现的`syscall`函数中，使用内联汇编编写的`ecall`指令，也是一条特殊的执行环境切换指令。

## 荣誉准则
在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

ChatGPT: 询问桶计数的含义

此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

https://five-embeddev.com/riscv-priv-isa-manual/Priv-v1.12/supervisor.html

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。